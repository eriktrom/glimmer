<html>
  <head>
    <title>Glimmer Ripples</title>
    <style type="text/css">
      html, body {
        margin: 0;
        padding: 0;
      }
    </style>

    <script data-template-name="application" type="text/x-handlebars-template">
      <svg id="none" width="{{width}}" height="{{height}}">
        <rect x="0" y="0" width="{{width}}" height="{{height}}" fill="#1B1B1B" />

        {{#each points.items key="key" as |point|}}
          <circle cx="{{point.x}}" cy="{{point.y}}" r="{{point.size}}" stroke-width="1" stroke="lightblue" stroke-opacity="{{point.opacity}}" fill-opacity="0" />
        {{/each}}

        <text fill="#ffffff" font-size="45" font-family="Verdana" x="0" y="{{height}}">{{count}} circles</text>
        <text fill="#ffffff" font-size="45" font-family="Verdana" x="400" y="{{height}}">{{fps}} fps</text>
      </svg>
    </script>
  </head>
  <body>

    <div id="output"></div>

    <script src="/bower_components/hammerjs/hammer.js"></script>
    <script src="../assets/loader.js"></script>
    <script>loader.noConflict({ define: 'enifed' });</script>
    <script src="../amd/glimmer-compiler.amd.js"></script>
    <script src="./demos.amd.js"></script>

    <script>
      function RingBuffer(capacity) {
        this.capacity = capacity;
        this.head     = 0;
        this.items    = new Array(capacity);
        this.length = 0;
      }

      RingBuffer.prototype.push = function(item) {
        this.items[this.head] = item;

        this.length++;
        this.head++;
        this.head %= this.capacity;
      };

      RingBuffer.prototype.remove = function(i) {
        this.length--;
        this.items[i] = undefined;
      };

      RingBuffer.prototype.forEach = function(callback, thisArg) {
        for (var i=0, l=this.items.length; i<l; i++) {
          if (this.items[i] === undefined) continue;
          callback.call(thisArg, this.items[i], i);
        }
      };

      function Point(timestamp, x, y) {
        this.key = null;
        this.timestamp = timestamp;

        this.x = x;
        this.y = y;
        this.size = 0.0;
        this.opacity = 1.0;
      };

      Point.prototype.update = function(index, currentTimestamp) {
        var delta = currentTimestamp - this.timestamp;

        this.size    = Math.max(delta/10, 0);
        this.opacity = Math.exp(-delta/250);
        this.key = String(index);
      };

      var compileTemplate = requireModule('glimmer-demos/index').compile,
          DemoEnvironment = requireModule('glimmer-demos/index').TestEnvironment;

      TEMPLATES = {};

      Array.prototype.slice.call(document.querySelectorAll("[data-template-name]")).forEach(function(node) {
        var name   = node.getAttribute("data-template-name"),
            source = node.textContent;

        TEMPLATES[name] = compileTemplate(source);
      });

      var env = new DemoEnvironment();

      env.registerHelper('if', function(params, hash, blocks) {
        if (!!params[0]) {
          blocks.template.yield();
        } else {
          blocks.inverse.yield();
        }
      });

      var output = document.getElementById('output');

      var START_X = output.offsetWidth / 2;
      var START_Y = (window.innerHeight - output.offsetHeight) / 2;

      var data = {
        width:  window.innerWidth,
        height: window.innerHeight,
        points: new RingBuffer(500), // in practice we only have 100-200 circles on screen
        count:  0,
        x: START_X,
        y: START_Y,
        fps:    0
      };

      var result = TEMPLATES['application'].render(data, env, { appendTo: output });

      window.addEventListener("resize", function() {
        output = document.getElementById('output');

        START_X = window.innerWidth / 2;
        START_Y = window.innerHeight / 2;

        data.x = START_X;
        data.y = START_Y;
        data.width  = window.innerWidth;
        data.height = window.innerHeight;
      });

      // document.addEventListener("mousemove", function(e) {
      //   data.points.push( new Point(e.timeStamp, e.offsetX, e.offsetY) );
      // });

      // document.addEventListener("touchstart", function(e) {
      //   data.points.push( new Point(e.timeStamp, e.offsetX, e.offsetY) );
      // });

      var touchActions = ['none'];
      Hammer.each(touchActions, function(touchAction) {
          var el = document.getElementById(touchAction);

          var mc = Hammer(el, {
              touchAction: touchAction
          });
          mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });
          mc.get('pinch').set({ enable: true });
          mc.get('rotate').set({ enable: true });

          mc.on("pan tap doubletap press", function(e) {
            data.points.push( new Point(e.timeStamp, START_X + e.deltaX, START_Y + e.deltaY) );
          });
      });

      var baseOffset = Date.now() - window.performance.now();
      var timestamp  = window.performance.now();

      function tick() {
        var _timestamp = window.performance.now()

        var delta = _timestamp - timestamp;

        timestamp = _timestamp;

        data.fps   = (1000 / delta).toPrecision(4);
        data.count = 0;

        var walltime = baseOffset + timestamp;

        data.points.forEach(function(point, i) {
          if (point) {
            point.update(i, walltime);

            if (point.opacity > 0.001) {
              data.count++;
            } else {
              data.points.remove(i);
            }
          }
        });

        result.rerender(data);

        window.requestAnimationFrame(tick);
      }

      tick();
    </script>
  </body>
</html>
