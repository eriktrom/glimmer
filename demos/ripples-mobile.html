<!DOCTYPE html>
<html>
  <head>
    <title>Glimmer Ripples</title>
    <style type="text/css">
      html, body {
        margin: 0;
        padding: 0;
      }

      #nav {
        font-size: 2em;
        line-height: 2em;
        position: absolute;
        top: 5px;
        left: 5px;
      }

      #nav a {
        text-decoration: none;
        color: white;
        margin: 0 10px;
        cursor: pointer;
      }

      #log {
        position: absolute;
        top: 50px;
        padding: 10px;
        color: white;
        font-weight: 100;
        font-size: .8em;
      }
    </style>

    <script data-template-name="application" type="text/x-handlebars-template">
      <svg id="none" width="{{width}}" height="{{height}}">
        <rect x="0" y="0" width="{{width}}" height="{{height}}" fill="#1B1B1B" />

        {{#each points.items key="key" as |point|}}
          <circle cx="{{point.x}}" cy="{{point.y}}" r="{{point.size}}" stroke-width="1" stroke="lightblue" stroke-opacity="{{point.opacity}}" fill-opacity="0" />
        {{/each}}

        {{#each events key="key" as |event|}}
          <text fill="#ffffff" font-size="10" font-family="Verdana" x="{{event.x}}" y="{{event.y}}">{{event.name}}</text>
        {{/each}}

        <text fill="#ffffff" font-size="45" font-family="Verdana" x="0" y="{{height}}">{{count}} circles</text>
        <text fill="#ffffff" font-size="45" font-family="Verdana" x="300" y="{{height}}">{{fps}} fps</text>
        <text fill="#ffffff" font-size="45" font-family="Verdana" x="600" y="{{height}}">{{eventsCount}} Gestures</text>
      </svg>
    </script>
  </head>
  <body>

    <div id="nav">
      <a href="./compile-and-run.html">Compile &amp; Run</a>
      <a href="./reference.html">Reference</a>
      <a href="./ripples.html">Ripples</a>
      <a href="./ripples-mobile.html">Ripples Mobile</a>
      <a href="./uptime-boxes.html">Uptime Boxes</a>
    </div>

    <div id="output"></div>

    <script>
      /* globals requireModule, window, loader, Hammer */
      /* jshint -W069, -W064 */
    </script>
    <script src="../assets/hammer.min.js"></script>
    <script src="../assets/loader.js"></script>
    <script>loader.noConflict({ define: 'enifed' });</script>
    <script src="../amd/glimmer-compiler.amd.js"></script>
    <script src="./demos.amd.js"></script>

    <script>
      function RingBuffer(capacity) {
        this.capacity = capacity;
        this.head     = 0;
        this.items    = new Array(capacity);
        this.length = 0;
      }

      RingBuffer.prototype.push = function(item) {
        this.items[this.head] = item;

        this.length++;
        this.head++;
        this.head %= this.capacity;
      };

      RingBuffer.prototype.remove = function(i) {
        this.length--;
        this.items[i] = undefined;
      };

      RingBuffer.prototype.forEach = function(callback, thisArg) {
        for (var i=0, l=this.items.length; i<l; i++) {
          if (this.items[i] === undefined) continue;
          callback.call(thisArg, this.items[i], i);
        }
      };

      function Point(timestamp, x, y) {
        this.key = null;
        this.timestamp = timestamp;

        this.x = x;
        this.y = y;
        this.size = 0.0;
        this.opacity = 1.0;
      }

      Point.prototype.update = function(index, currentTimestamp) {
        var delta = currentTimestamp - this.timestamp;

        this.size    = Math.max(delta/10, 0);
        this.opacity = Math.exp(-delta/250);
        this.key = String(index);
      };


      var DemoEnvironment = requireModule('glimmer-demos').TestEnvironment;
      var env = new DemoEnvironment();

      var TEMPLATES = {};

      Array.prototype.slice.call(document.querySelectorAll("[data-template-name]")).forEach(function(node) {
        var name   = node.getAttribute("data-template-name"),
            source = node.textContent;

        TEMPLATES[name] = env.compile(source);
      });

      env.registerHelper('if', function(params, hash, blocks) {
        if (!!params[0]) {
          blocks.template.yield();
        } else {
          blocks.inverse.yield();
        }
      });

      var log = document.getElementById("log");
      function logEvent(str) {
        log.insertBefore(document.createTextNode(str +"\n"), log.firstChild);
      }

      var output = document.getElementById('output');
      output.innerHTML = null;

      var data = {
        width:  window.innerWidth,
        height: window.innerHeight,
        points: new RingBuffer(500), // in practice we only have 100-200 circles on screen
        count:  0,
        fps:    0,
        events: []
      };

      var result = TEMPLATES['application'].render(data, env, { appendTo: output });

      window.addEventListener("resize", function() {
        data.width  = window.innerWidth;
        data.height = window.innerHeight;
      });

      var touchAction = 'none';
      var el = document.getElementById(touchAction);

      var mc = new Hammer.Manager(el, {
        touchAction: touchAction
      });

      mc.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));

      mc.add(new Hammer.Swipe()).recognizeWith(mc.get('pan'));
      mc.add(new Hammer.Rotate({ threshold: 0 })).recognizeWith(mc.get('pan'));
      mc.add(new Hammer.Pinch({ threshold: 0 })).recognizeWith([mc.get('pan'), mc.get('rotate')]);

      mc.add(new Hammer.Tap({ event: 'doubletap', taps: 2 }));
      mc.add(new Hammer.Tap());

      mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });

      // bad code, very poor, want to see stuff, dont copy me
      var counter = 0, hCounter = 100, offset = 0;
      function calcWidth(width) {
        width *= 10; // 10*length of event name, dont know what spacing we're using
                     // points are different than pixels, this is a crappy 'guess'

        if (counter === 1) { offset = width; return 0; } // cognitive disonence, counter is incremented
                                                         // in the mc.on handler, booyah biotch


        // when we wrap at window width, set offset to current word length, start over
        if (offset > data.width-50) {
          hCounter += 25;
          offset = width;
          return 0;
        }

        var result = offset; // get result, which is the offset *now*
        offset += width; // increment offset for next iteration
        return result; // return the goods
      }

      mc.on("swipe panstart panmove press pressup tap doubletap pinch pinchmove rotatestart rotatemove", function(e) {
        data.points.push( new Point(e.timeStamp, e.center.x, e.center.y) );
        data.events.push( { key: counter+=1, name: e.type, x: calcWidth(e.type.length), y: hCounter } );
      });

      var baseOffset = Date.now() - window.performance.now();
      var timestamp  = window.performance.now();

      function tick() {
        var _timestamp = window.performance.now();

        var delta = _timestamp - timestamp;

        timestamp = _timestamp;

        data.fps   = (1000 / delta).toPrecision(4);
        data.count = 0;
        data.eventsCount = counter;

        var walltime = baseOffset + timestamp;

        data.points.forEach(function(point, i) {
          if (point) {
            point.update(i, walltime);

            if (point.opacity > 0.001) {
              data.count++;
            } else {
              data.points.remove(i);
            }
          }
        });

        result.rerender(data);

        window.requestAnimationFrame(tick);
      }

      tick();
    </script>
  </body>
</html>
